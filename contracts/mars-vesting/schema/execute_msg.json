{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "anyOf": [
    {
      "description": "Implementation of cw20 receive msg",
      "type": "object",
      "required": [
        "receive"
      ],
      "properties": {
        "receive": {
          "$ref": "#/definitions/Cw20ReceiveMsg"
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Stake all vested but not-yet-withdrawn MARS (locked and unlocked), receive xMARS",
      "type": "object",
      "required": [
        "stake"
      ],
      "properties": {
        "stake": {
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Claim withdrawable MARS and xMARS",
      "type": "object",
      "required": [
        "withdraw"
      ],
      "properties": {
        "withdraw": {
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Give up allocation, refund all unvested tokens to `config.fallback_recipient`",
      "type": "object",
      "required": [
        "terminate"
      ],
      "properties": {
        "terminate": {
          "type": "object"
        }
      },
      "additionalProperties": false
    },
    {
      "description": "If the global default unlocking schedule is set to None at instantiation, the protocol admin can update it. However, it the value is set, then it cannot be set again. In other words, only None -> Some(..), not Some(..) -> Some(..)",
      "type": "object",
      "required": [
        "set_default_unlock_schedule"
      ],
      "properties": {
        "set_default_unlock_schedule": {
          "type": "object",
          "required": [
            "default_unlock_schedule"
          ],
          "properties": {
            "default_unlock_schedule": {
              "$ref": "#/definitions/Schedule"
            }
          }
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
      "type": "string"
    },
    "Cw20ReceiveMsg": {
      "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
      "type": "object",
      "required": [
        "amount",
        "msg",
        "sender"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "msg": {
          "$ref": "#/definitions/Binary"
        },
        "sender": {
          "type": "string"
        }
      }
    },
    "Schedule": {
      "type": "object",
      "required": [
        "cliff",
        "duration",
        "start_time"
      ],
      "properties": {
        "cliff": {
          "description": "Number of seconds starting UST during which no token will be vested/unlocked",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "duration": {
          "description": "Number of seconds taken since UST for tokens to be fully vested/unlocked",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "start_time": {
          "description": "Timestamp of when vesting/unlocking is to be started (in seconds)",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
